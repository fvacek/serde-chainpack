use chrono::{DateTime, FixedOffset};
use serde::{Deserialize, Serialize};
use serde_chainpack::{de::Deserializer, ser::Serializer, types::CP_DATETIME};

#[derive(Debug, PartialEq, Serialize, Deserialize)]
struct TestDateTime {
    #[serde(with = "serde_chainpack::chrono_datetime")]
    dt: DateTime<FixedOffset>,
}

#[test]
fn test_datetime() {
    let dt = TestDateTime {
        dt: DateTime::parse_from_rfc3339("2024-01-26T10:54:21+01:00").unwrap(),
    };
    let mut buffer = Vec::new();
    let mut serializer = Serializer::new(&mut buffer);
    dt.serialize(&mut serializer).unwrap();

    let mut deserializer = Deserializer::from_reader(&buffer[..]);
    let value: TestDateTime = TestDateTime::deserialize(&mut deserializer).unwrap();
    assert_eq!(value, dt);
}

#[test]
fn test_datetime_examples() {
    let test_cases = vec![
        ("2018-02-02T00:00:00.001+00:00", vec![CP_DATETIME, 0b00000100]),
        ("2018-02-02T01:00:00.001+01:00", vec![CP_DATETIME, 0x01, 0x00, 0x00, 0x00, 0x01, 0x61, 0xa6, 0x83, 0xe1, 0x00, 0x0e, 0x10]),
        ("2018-12-02T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x67, 0x69, 0x95, 0x80, 0x00, 0x00, 0x00]),
        ("2018-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x60, 0xd3, 0xc2, 0x00, 0x00, 0x00, 0x00]),
        ("2019-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x67, 0xf9, 0x26, 0x80, 0x00, 0x00, 0x00]),
        ("2020-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x6f, 0x1e, 0x8a, 0x80, 0x00, 0x00, 0x00]),
        ("2021-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x76, 0x43, 0xee, 0x80, 0x00, 0x00, 0x00]),
        ("2031-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0xc9, 0x9a, 0x5e, 0x80, 0x00, 0x00, 0x00]),
        ("2041-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1c, 0xf1, 0xce, 0x80, 0x00, 0x00, 0x00]),
        ("2041-03-04T00:00:00-10:15", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x02, 0x1d, 0x6b, 0x5d, 0xc0, 0xff, 0xff, 0x13, 0x44]),
        ("2041-03-04T00:00:00.123-10:15", vec![CP_DATETIME, 0x7b, 0x00, 0x00, 0x00, 0x02, 0x1d, 0x6b, 0x5d, 0xc0, 0xff, 0xff, 0x13, 0x44]),
        ("1970-01-01T00:00:00+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]),
        ("2017-05-03T05:52:03+00:00", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5b, 0x96, 0x0c, 0x23, 0x00, 0x00, 0x00]),
        ("2017-05-03T15:52:03.923Z", vec![CP_DATETIME, 0x93, 0x03, 0x00, 0x00, 0x01, 0x5b, 0x96, 0x0c, 0x23, 0x00, 0x00, 0x00]),
        ("2017-05-03T15:52:31.123+10:00", vec![CP_DATETIME, 0x7b, 0x00, 0x00, 0x00, 0x01, 0x5b, 0x96, 0x0c, 0x23, 0x00, 0x08, 0xca, 0x00]),
        ("2017-05-03T15:52:03Z", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5b, 0x96, 0x0c, 0x23, 0x00, 0x00, 0x00]),
        ("2017-05-03T15:52:03-01:30", vec![CP_DATETIME, 0x00, 0x00, 0x00, 0x00, 0x01, 0x5b, 0x96, 0x0c, 0x23, 0xff, 0xff, 0xea, 0xac]),
        ("2017-05-03T15:52:03.923+00:00", vec![CP_DATETIME, 0x93, 0x03, 0x00, 0x00, 0x01, 0x5b, 0x96, 0x0c, 0x23, 0x00, 0x00, 0x00]),
    ];

    for (dt_str, expected) in test_cases {
        println!("dt: {dt_str}, expected: {expected:x?}");
        let dt = TestDateTime {
            dt: DateTime::parse_from_rfc3339(dt_str).unwrap(),
        };
        let mut buffer = Vec::new();
        let mut serializer = Serializer::new(&mut buffer);
        dt.serialize(&mut serializer).unwrap();
        assert_eq!(buffer, expected);

        let mut deserializer = Deserializer::from_reader(&buffer[..]);
        let value: TestDateTime = TestDateTime::deserialize(&mut deserializer).unwrap();
        assert_eq!(value, dt);
    }
}
